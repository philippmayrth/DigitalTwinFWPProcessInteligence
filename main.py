from typing import *
import pandas as pd
import numpy as np
import datetime
import uuid
from dataclasses import dataclass
import timeit


OpeningHours = NewType("OpeningHours", pd.DataFrame)
PreparedData = NewType("PreparedData", pd.DataFrame)


def getHoursFor8760Model(year: int=2023) -> List[datetime.datetime]:
    # Source: P. Mayr, Codebase of https://pvrechner.avalonsoft.de (Accessed: 2023-10-25)
    """Returns the datetime for every hour in the year

    Args:
        startYear (int, optional): _description_. Defaults to 2023.

    Returns:
        List[datetime.datetime]: _description_
    """
    assert len(str(year)) == 4, "invalid year"
    dates = []
    iDay = datetime.datetime.strptime(f'{year}-01-01','%Y-%m-%d')
    for _ in range(365 * 24):
        dates.append(iDay)
        iDay = iDay + datetime.timedelta(hours=1)
    return dates

def getOpeningHours() -> OpeningHours:
    openWeekdays: Callable = lambda h: True if h >= 17 and h <= 22 else False
    openWeekends: Callable = lambda h: True if h >= 12 and h <= 24 else False
    df = pd.DataFrame()
    hours = [hour+1 for hour in range(24)]
    df["hour"] = hours
    df["monday"] = df["hour"].apply(openWeekdays)
    df["tuesday"] = df["hour"].apply(openWeekdays)
    df["wednesday"] = df["hour"].apply(openWeekdays)
    df["thursday"] = df["hour"].apply(openWeekdays)
    df["friday"] = df["hour"].apply(openWeekdays)
    df["saturday"] = df["hour"].apply(openWeekends)
    df["sunday"] = df["hour"].apply(openWeekends)
    return df

def getPreparedDF(hoursOfYear: List[datetime.datetime], openingHours: OpeningHours) -> PreparedData:
    df = pd.DataFrame(hoursOfYear, columns=["date"])
    df["weekday"] = df["date"].apply(lambda d: d.weekday())
    df["isWeekend"] = df["weekday"].apply(lambda d: True if d >= 5 else False)
    weeknames = ["monday", "tuesday", "wednesday", "thursday", "friday", "saturday", "sunday"]
    df["isOpen"] = df["date"].apply(lambda date: openingHours.loc[date.hour, weeknames[date.weekday()]])
    return df


def addOrders(df: PreparedData) -> pd.DataFrame:
    def dummyOrders(df) -> int:
        # TODO: Replace this function with one that takes into account a normal distribution of orders per hour on a given day
        isOpen = df["isOpen"]
        if df["isWeekend"]:
            return 20 if isOpen else 0 # more traffic on weekends
        return 10 if isOpen else 0
    df["orders"] = df.apply(dummyOrders, axis=1)
    return df


@dataclass(frozen=True)
class Pizza:
    name: str
    # ingredients: Tuple[str]


def convertOrdersByHoursToIndividualOrders(ordersByHours: pd.DataFrame, offeredPizzas: Tuple[Pizza]) -> pd.DataFrame:
    assert len(offeredPizzas) > 0, "offered pizza must be at least one"
    # drop all rows that have no orders
    ordersByHours = ordersByHours[ordersByHours["orders"] > 0]
    # create a new dataframe with individual orders so we simulate the process
    df = pd.DataFrame()

    # Create a new row for each order
    # Loop thourgh each row in the ordersByHours dataframe
    # Loop thruogh the number of orders in that row
    # Concat that many rows to the new dataframe
    df = pd.concat([pd.DataFrame([row for _ in range(row["orders"])]) for _, row in ordersByHours.iterrows()])
    df.drop(columns=["orders"], inplace=True)
    df.drop(columns=["isWeekend"], inplace=True)
    df.drop(columns=["weekday"], inplace=True)
    df.drop(columns=["isOpen"], inplace=True)

    # Timestamp is generated by randomly adding minutes and seconds to the hour. This is required because we started with a dataframe that includes only every hour of the year.
    df["addRandomSeconds"] = df["date"].apply(lambda _: np.random.randint(0, 60 * 60)) # 60 seconds * 60 minutes = seconds in 1 hour
    df["timestamp"] = df["date"] + df["addRandomSeconds"].apply(lambda s: datetime.timedelta(seconds=s))
    df.drop(columns=["addRandomSeconds"], inplace=True)
    
    df["caseId"] = [uuid.uuid4() for _ in range(len(df))]
    availableOrderMethods = ["phone", "website", "counter"]
    df["orderMethod"] = None
    df["orderMethod"] = df["orderMethod"].apply(lambda _: np.random.choice(availableOrderMethods))
    df["pizza"] = None
    df["pizza"] = df["pizza"].apply(lambda _: np.random.choice(offeredPizzas))
    return df


def calc():
    # TODO: Figure out the actual opening hours based on the data
    hours = getHoursFor8760Model()
    df = getPreparedDF(hours, getOpeningHours())
    df = addOrders(df)
    pizzas = convertOrdersByHoursToIndividualOrders(df, offeredPizzas=[Pizza("Margherita"), Pizza("Salami"), Pizza("Hawaii"), Pizza("Funghi"), Pizza("Quattro Formaggi"), Pizza("Diavolo"), Pizza("Vegetariana"), Pizza("Tonno"), Pizza("Capricciosa"), Pizza("Prosciutto")])
    return pizzas

if __name__ == "__main__":
    # TODO: Figure out the actual opening hours based on the data
    print(calc())

